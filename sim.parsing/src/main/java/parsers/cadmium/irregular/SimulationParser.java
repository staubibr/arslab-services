package parsers.cadmium.irregular;

import java.io.IOException;
import java.io.InputStream;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.stream.Stream;

import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;

import components.parsing.ISimulationParser;
import components.simulation.Message;
import components.simulation.Messages;
import components.simulation.Model;
import components.simulation.Structure;
import components.simulation.StructureInfo;
import components.utilities.Helper;

public class SimulationParser implements ISimulationParser {

	@Override
	public void SetInfo(Structure structure, HashMap<String, byte[]> files) {
		String name = Helper.FindName(files,  "message");
		
		StructureInfo info = new StructureInfo(name, "Cadmium", "Irregular Cell-DEVS");
		
		structure.setInfo(info);
	}
    
	@Override
	public Structure ParseStructure(HashMap<String, byte[]> files) throws IOException {
		Structure structure = new Structure();

		this.SetInfo(structure, files);
		
		InputStream json = Helper.FindFileStream(files, ".json");
		
		ObjectMapper mapper = new ObjectMapper();
		
		JsonNode node = mapper.readTree(json);
		
		json.close();
		
		List<String> fields = new ArrayList<String>();
		
		node.get("fields").forEach(f -> fields.add("\"" + f.asText() + "\""));
		
		String template = "[" + String.join(",", fields) + "]";
		
		Iterator<String> cells = node.get("cells").fieldNames();
		
		cells.next();
		
		while (cells.hasNext()) {			
			Model model = new Model(cells.next(), components.simulation.Model.Type.ATOMIC, template);
			
			structure.AddModel(model);
		}
		
		return structure;
	}

	@Override
	public Messages ParseResults(Structure structure, HashMap<String, byte[]> files) throws IOException {
		InputStream log = Helper.FindFileStream(files, "message");
		
		Messages output = new Messages();
		
		List<Message> messages = new ArrayList<Message>();
		
		Helper.ReadFile(log, (String l) -> {
			// [Sender_defs::packetSentOut: {1}, Sender_defs::ackReceivedOut: {}, Sender_defs::dataOut: {<1, 0>}] generated by model sender1
			if (l.startsWith("[")) {
				int i = l.indexOf('{') + 1;
				int j = l.indexOf('}') - 1;

				String[] content = Stream.of(l.substring(i, j).split(";")).map(s -> s.trim()).toArray(String[]::new);
				
				String name = content[0];
				String values = content[1].substring(1);
				
				messages.add(new Message(output.getTimesteps().size() - 2, structure.FindNode(name), values));
			}
			
			else output.getTimesteps().add(l);
		});
		
		log.close();
		
		// Cadmium has an extra timestep 0
		output.getTimesteps().remove(0);

		output.setMessages(messages);
		
		return output;
	}

	@Override
	public Boolean Detect(HashMap<String, byte[]> files) throws IOException {
		// [cadmium::celldevs::cell_ports_def<std::string, sir>::cell_out: {Alta Vista ; <1,0.485,0.515,0,0.515,0,0>}] generated by model _Alta Vista

		InputStream messages = Helper.FindFileStream(files, "message");
		// InputStream states = files.FindStream("state");

		// TODO : For now, only messages is mandatory, states is not used. This is just a port of what we had client side.
		// Eventually, this should work with either of the files but one at least. We want to be able to handle messages 
		// exchanges or model states, but at least one or the other
		// if (messages == null && states == null) return false;
		if (messages == null) return false;
		
		List<String> lines = Helper.ReadNLines(messages, 3);

		messages.close();

		return lines.get(2).contains("cadmium::celldevs") && !lines.get(2).contains("std::vector");
	}
}
