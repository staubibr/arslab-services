package parsers.cadmium;

import java.io.IOException;
import java.io.InputStream;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

import com.fasterxml.jackson.databind.ObjectMapper;

import components.FilesMap;
import components.Helper;
import models.simulation.Link;
import models.simulation.Message;
import models.simulation.Port;
import models.simulation.Structure;
import models.simulation.StructureInfo;
import parsers.ILogParser;
import parsers.cadmium.config.devs.Model;

public class Devs implements ILogParser {

	private static final String TEMPLATE = "{\"value\":${0}}";
	
	@Override
	public Structure Parse(FilesMap files) throws IOException {
		Structure structure = ParseStructure(files.FindStream(".json"));
		
		structure.setInfo(new StructureInfo(files.FindName("message"), "Cadmium", "DEVS"));
		
		ParseLog(structure, files.FindStream("message"));
				
		return structure;
	}

	public Structure ParseStructure(InputStream json) throws IOException {	
		Structure s = new Structure();
		
		ObjectMapper mapper = new ObjectMapper();
		
		Model jModel = mapper.readValue(json, Model.class);
		
		jModel.Traverse(m -> {
			models.simulation.Model.Type mType = m.getSubmodels().size() > 0 ? models.simulation.Model.Type.COUPLED :  models.simulation.Model.Type.ATOMIC; 
			
			models.simulation.Model sModel = s.CreateModel(m.getName(), mType, TEMPLATE);
			
			m.getPorts().forEach(p -> {
				models.simulation.Port.Type pType = p.getType() == "output" ? models.simulation.Port.Type.OUTPUT : models.simulation.Port.Type.INPUT;
				
				s.CreatePort(sModel, p.getName(), pType, TEMPLATE);
			});
		});
		
		jModel.Traverse(m -> {
			m.getCouplings().forEach(c -> {
				c.setModel(m.getName());

				models.simulation.Port start = s.FindPort(c.getModelA(), c.getPortA());
				models.simulation.Port end = s.FindPort(c.getModelB(), c.getPortB());
				
				s.getLinks().add(new Link(start, end));
			});
		});

		return s;
	}
	
	private void ParseLog(Structure structure, InputStream log) throws IOException {
		List<Message> messages = new ArrayList<Message>();
		
		Helper.ReadFile(log, (String l) -> {
			// [Sender_defs::packetSentOut: {1}, Sender_defs::ackReceivedOut: {}, Sender_defs::dataOut: {<1, 0>}] generated by model sender1
			if (l.startsWith("[")) {
				int i = l.indexOf(']') + 1;

				String left = l.substring(0, i);
				String right = l.substring(i); 
				
				// Read model name from right hand side
				String m = right.trim().split(" ")[3];
				
				// Process left hand side
				String clean = left.substring(1, left.length() - 1).replace(" ", "").replace("::",  ":");
				
				Arrays.stream(clean.split("\\}")).forEach(s -> {
					// Sender_defs:packetSentOut:{1}
					String[] e = s.split(":");
					
					String v = e[e.length - 1].replaceAll("\\{|\\}|<|>|\\s", "");					
					
					if (v.length() == 0) return;
					
					String p = e[e.length - 2];
													
					Port port = structure.FindPort(m, p);
															
					messages.add(new Message(structure.getTimesteps().size() - 2, port, v.split(",")));
				});
			}
			
			else structure.getTimesteps().add(l);
		});
		
		// Cadmium has an extra timestep 0
		structure.getTimesteps().remove(0);
		
		structure.setMessages(messages);
	}
	
	public Boolean Validate(FilesMap files) throws IOException {
		InputStream messages = files.FindStream("message");
		// InputStream states = files.FindStream("state");

		// TODO : For now, only messages is mandatory, states is not used. This is just a port of what we had client side.
		// Eventually, this should work with either of the files but one at least. We want to be able to handle messages 
		// exchanges or model states, but at least one or the other
		// if (messages == null && states == null) return false;
		if (messages == null) return false;
		
		List<String> lines = Helper.ReadNLines(messages, 3);

		messages.reset();
		
		long n1 = lines.get(2).chars().filter(c -> c == '(').count();
		long n2 = lines.get(2).chars().filter(c -> c == ')').count();

		// Shouldn't have any parentheses becasue no coordinates
		// TODO: Super shady, flimsy, etc. Figure out how to distinguish different formats properly.
		return n1 == 0 && n2 == 0;
	}
}
